###
### Data Generator for 3-Group CER Simulation
################################################################################


##' Generate MVN covariates Z_i
##'
##' .. content for \details{} ..
##'
##' @param n Sample size
##' @param mu Mean vector
##' @param Sigma Positive definite variance-covariance matrix
##'
##' @return a data_frame of Z_i MVN covariates
##'
##' @author Kazuki Yoshida
##' @export
generate_mvn_covariates <- function(n, mu, Sigma) {

    assertthat::assert_that(length(n) == 1)
    assertthat::assert_that(is.numeric(n))
    assertthat::assert_that(is.numeric(mu))
    assertthat::assert_that(ncol(Sigma) == length(mu))
    assertthat::assert_that(nrow(Sigma) == length(mu))

    out <- tibble::as_data_frame(
                       MASS::mvrnorm(n = n,
                                     mu = mu,
                                     Sigma = Sigma)
                   )

    names(out) <- gsub("V", "Z", names(out))

    out
}


##' Generate covariates X_i given Z_i and probabilities
##'
##' .. content for \details{} ..
##'
##' @param df data_frame generated by generate_latent_covariates
##' @param prob vector of probabilities of 1 for X_i. If NA is used, X_i := Z_i.
##'
##' @return a data_frame of X_i covariates
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_covariates <- function(df, prob) {

    assertthat::assert_that(ncol(df) == length(prob))

    ## Threshold vector.
    thres <- -qnorm(prob)

    ## Loop over threshold values
    for (i in seq_along(thres)) {
        if (!is.na(thres[i])) {
            ## Only work if threshold is given
            df[,i] <- as.numeric(df[,i] > thres[i])
        }
        ## Nothing happens if thres[i] is NA
    }

    ## rename
    names(df) <- gsub("Z", "X", names(df))

    df
}


##' Generate a binary treatment
##'
##' .. content for \details{} ..
##'
##' @param df df generated by generate_bin_covariates
##' @param alphas true coefficients for the logistic treatment generating model. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_treatment <- function(df, alphas) {

    assertthat::assert_that(ncol(df) == (length(alphas) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictor
    lpA1 <- as.numeric(Xs %*% alphas)

    ## P[A=1|X] (true PS)
    df$pA1 <- locfit::expit(lpA1)

    ## Bernoulli(pA)
    df$A <- rbinom(n = length(df$pA1),
                   size = 1,
                   prob = df$pA1)

    df
}


##' Generate a three-valued treatment
##'
##' .. content for \details{} ..
##'
##' @param df df generated by generate_bin_covariates
##' @param alphas1 true coefficients for the first logistic treatment generating model. This vector should contain the intercept.
##' @param alphas2 true coefficients for the second logistic treatment generating model. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
##' @export
generate_tri_treatment <- function(df, alphas1, alphas2) {

    assertthat::assert_that(ncol(df) == (length(alphas1) - 1))
    assertthat::assert_that(ncol(df) == (length(alphas2) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictors
    lpA1 <- as.numeric(Xs %*% alphas1)
    lpA2 <- as.numeric(Xs %*% alphas2)

    ## P[A=1|X]/P[A=0|X]
    exp_lpA1 <- exp(lpA1)
    ## P[A=2|X]/P[A=0|X]
    exp_lpA2 <- exp(lpA2)

    ## Common denominator
    denom <- 1 + exp_lpA1 + exp_lpA2

    ## True propensity scores
    df$pA0 <- 1        / denom
    df$pA1 <- exp_lpA1 / denom
    df$pA2 <- exp_lpA2 / denom

    ## n x 3 matrix of true propensity scores
    pA_mat <- cbind(df$pA0, df$pA1, df$pA2)

    ## Generate treatment assignment indicator matrix
    A_mat <- pA_mat_to_A_mat(pA_mat)

    ## Generate three-valued vector
    df$A <- A_indicator_mat_to_multinom_A_vec(A_mat)

    ## Return the augmented data_frame
    df
}

pA_mat_to_A_mat <- function(pA_mat) {

    ## pA_mat is a n x 3 matrix of probability vectors (rows).

    ## transposed 3 x n data_frame
    pA_tr_df <- tibble::as_data_frame(t(pA_mat))

    ## Loop over individuals to obtain n x 3 matrix of treatment indicators.
    A_mat <- lapply(as.list(pA_tr_df),
                    function(pA_vec) {
                        rmultinom(n = 1, size = 1, prob = pA_vec)
                    }) %>%
        do.call(cbind, .) %>%
        t

    A_mat
}

A_indicator_mat_to_multinom_A_vec <- function(A_mat) {

    ## A_mat is a n x 3 matrix of treatment indicators.
    as.numeric(A_mat %*% matrix(c(0,1,2)))
}


##' Generate binary outcome given X_i and three-valued A_i
##'
##' .. content for \details{} ..
##'
##' @param df data_frame containing X_i and A_i
##' @param beta0 Intercept coefficient
##' @param betaA1 Coefficient for I(A_i = 1)
##' @param betaA2 Coefficient for I(A_i = 2)
##' @param betaX Coefficient vector for covariates X_i
##' @param betaXA1 Interaction coefficients for covariates when A_i = 1
##' @param betaXA2 Interaction coefficients for covariates when A_i = 2
##'
##' @return data_frame with binary Y added
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_outcome_log_tri_treatment <- function(df, beta0, betaA1, betaA2, betaX, betaXA1, betaXA2) {

    colnames_starting_with_X <- Filter(f = function(elt) {grepl("^X", elt)}, x = names(df))

    assertthat::assert_that(length(beta0) == 1)
    assertthat::assert_that(length(betaX) == length(colnames_starting_with_X))
    assertthat::assert_that(length(betaA1) == 1)
    assertthat::assert_that(length(betaA2) == 1)
    assertthat::assert_that(length(betaXA1) == length(betaX))
    assertthat::assert_that(length(betaXA2) == length(betaX))

    ## Extract X part as a matrix
    Xs <- as.matrix(df[,colnames_starting_with_X])

    ## Construct treatment indicators from A in {0,1,2}
    A1 <- as.numeric(df$A == 1)
    A2 <- as.numeric(df$A == 2)

    ## Linear predictor matrix (n x 1)
    lpY <- beta0 +
        (betaA1 * A1) +
        (betaA2 * A2) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * A1 +
        Xs %*% matrix(betaXA2) * A2

    assertthat::assert_that(nrow(lpY) == nrow(df))
    assertthat::assert_that(ncol(lpY) == 1)

    ## Counterfactual linear predictors
    lpYA0 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 0
    lpYA1 <- beta0 +
        (betaA1 * 1) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 1 +
        Xs %*% matrix(betaXA2) * 0
    lpYA2 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 1

    ## Tentative probability of binary outcome Y
    pY  <- exp(as.numeric(lpY))
    pYA0 <- exp(as.numeric(lpYA0))
    pYA1 <- exp(as.numeric(lpYA1))
    pYA2 <- exp(as.numeric(lpYA2))

    ## Truncate at 1 to avoid a probability beyond 1.
    pY[pY > 1] <- 1
    pYA0[pYA0 > 1] <- 1
    pYA1[pYA1 > 1] <- 1
    pYA2[pYA2 > 1] <- 1

    ## Add to data_frame
    df$pYA0 <- pYA0
    df$pYA1 <- pYA1
    df$pYA2 <- pYA2
    df$pY <- pY

    ## Bernoulli(p_i) draw based on true risk of disease
    df$Y <- rbinom(n = length(pY), size = 1, prob = pY)

    ## Add class datagen3
    class(df) <- c("datagen3", class(df))

    df
}

##' Print method for simulated data
##'
##' .. content for \details{} ..
##'
##' @param x data_frame with an additional class \code{datagen3}
##' @param ...
##'
##' @return invisibly return a matrix object
##'
##' @author Kazuki Yoshida
##' @export
print.datagen3 <- function(x, ...) {

    ## Construct
    tab_overall <- print(tableone::CreateTableOne(data = x),
                         printToggle = FALSE)
    tab_strata  <- print(tableone::CreateTableOne(data = x, strata = "A", test = FALSE, smd = TRUE),
                         smd = TRUE, printToggle = FALSE)
    tab_combo <- cbind(tab_overall, tab_strata)

    print(tab_combo, quote = FALSE)

    invisible(tab_combo)
}


##' Generate binary outcome given X_i and binary A_i
##'
##' .. content for \details{} ..
##'
##' @param df data_frame containing X_i and A_i
##' @param betas coefficients for the outcome model
##'
##' @return data_frame with binary Y added
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_outcome_log_bin_treatment <- function(df, beta0, betaX, betaA1, betaXA1) {

    colnames_starting_with_X <- Filter(f = function(elt) {grepl("^X", elt)}, x = names(df))

    assertthat::assert_that(length(beta0) == 1)
    assertthat::assert_that(length(betaX) == length(colnames_starting_with_X))
    assertthat::assert_that(length(betaA1) == 1)
    assertthat::assert_that(length(betaXA1) == length(betaX))

    ## Extract X part as a matrix
    Xs <- as.matrix(df[,colnames_starting_with_X])

    ## Construct treatment indicators from A in {0,1}
    A1 <- df$A

    ## Linear predictor matrix (n x 1)
    lpY <- beta0 +
        (betaA1 * A1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * A1

    assertthat::assert_that(nrow(lpY) == nrow(df))
    assertthat::assert_that(ncol(lpY) == 1)

    ## Counterfactual linear predictors
    lpYA0 <- beta0 +
        (betaA1 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0
    lpYA1 <- beta0 +
        (betaA1 * 1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 1

    ## Tentative probability of binary outcome Y
    pY <- exp(as.numeric(lpY))
    pYA0 <- exp(as.numeric(lpYA0))
    pYA1 <- exp(as.numeric(lpYA1))

    ## Truncate at 1 to avoid a probability beyond 1.
    pY[pY > 1] <- 1
    pYA0[pYA0 > 1] <- 1
    pYA1[pYA1 > 1] <- 1

    ## Add to data_frame
    df$pYA0 <- pYA0
    df$pYA1 <- pYA1
    df$pY <- pY

    ## Bernoulli(p_i)
    df$Y <- rbinom(n = length(pY), size = 1, prob = pY)

    ## Add class datagen3
    class(df) <- c("datagen3", class(df))

    df
}
