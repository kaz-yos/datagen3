###
### Data Generator for 3-Group CER Simulation
################################################################################

###
### Generate covariate
################################################################################

###  Franklin
##' Generate covariates as in Franklin et al 2014
##'
##' .. content for details ..
##'
##' @param n sample size to simulated
##'
##' @return data_frame with n rows with 10 columns (X1 through X10)
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_franklin_covariates <- function(n) {

    ## Continuous
    X1     <- rnorm(n = n, mean = 0, sd = 1)
    X2     <- rlnorm(n = n, meanlog = 0, sdlog = 0.5)
    X3     <- rnorm(n = n, mean = 0, sd = 10)

    ## Binary
    ##  Dependent on X1; mean(pX4) = 0.5
    oddsX4 <- exp(2 * X1)
    pX4    <- oddsX4 / (1 + oddsX4)
    X4     <- rbinom(n = n, size = 1, prob = pX4)
    ##  Independent
    X5     <- rbinom(n = n, size = 1, prob = 0.2)

    ## Multinomial
    X6     <- as.numeric(c(1:5) %*% rmultinom(n = n, size = 1, prob = c(0.5,0.3,0.1,0.05,0.05)))

    ## Induced variables
    X7     <- sin(X1)
    X8     <- X2^2
    X9     <- X3 * X4
    X10    <- X4 * X5

    ## Output a data_frame
    data_frame(X1 = X1,
               X2 = X2,
               X3 = X3,
               X4 = X4,
               X5 = X5,
               X6 = X6,
               X7 = X7,
               X8 = X8,
               X9 = X9,
               X10 = X10)
}

###  Sturmer
##' Generate Sturmer's base covariates
##'
##' .. content for details ..
##'
##' @param n Sample size
##'
##' @return data_frame with X1-X6
##'
##' @author Kazuki Yoshida
generate_sturmer_base_covariates <- function(n) {

    data_frame(X1 = rbinom(n = n, size = 1, prob = 0.2),
               X2 = rbinom(n = n, size = 1, prob = 0.2),
               X3 = rbinom(n = n, size = 1, prob = 0.2),
               X4 = rnorm(n = n, mean = 0, sd = 1),
               X5 = rnorm(n = n, mean = 0, sd = 1),
               X6 = rnorm(n = n, mean = 0, sd = 1))
}

##' Generate Sturmer's unmeasured covariates
##'
##' .. content for details ..
##'
##' @param df data_frame generated by \code{\link{generate_sturmer_base_covariates}} containing X1-X6
##' @param base_alphas1 coefficients for the first linear predictor. This vector should contain the intercept.
##' @param base_alphas2 coefficients for the second linear predictor. This vector should contain the intercept.
##' @param prev_params Prevalence parameters. A vector of length 3.
##' @param contraindication Logical to determine whether to parametrize based on contraindication. If \code{TRUE}, the unmeasured binary variables are more common in the high PS regions (corners in the PS ternary plot). If \code{FALSE}, the unmeasured binary variables are more common in the low PS regions (edges in the PS ternary plot).
##'
##' @return data_frame with additional X7-X9, which are considered the rare unmeasured covariates in the tails of PS distribution.
##'
##' @author Kazuki Yoshida
generate_sturmer_unmeasured_covariates <- function(df, base_alphas1, base_alphas2, prev_params, contraindication) {

    assertthat::assert_that(ncol(df) + 1 == length(base_alphas1))
    assertthat::assert_that(ncol(df) + 1 == length(base_alphas2))

    ## Add initial predicted probabilities based on the base variables only.
    df <- generate_tri_treatment(df = df, alphas1 = base_alphas1, alphas2 = base_alphas2) %>%
        ## Rename them to first-step probability variables.
        rename(pA0_first = pA0,
               pA1_first = pA1,
               pA2_first = pA2) %>%
        ## Drop the assigned treatment at this step.
        select(-A)

    if (contraindication) {

        ## Contraindication: prevalence is increasing in the first-step PS.
        df$X7 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (df$pA0_first - prev_params[1]))
        df$X8 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (df$pA1_first - prev_params[2]))
        df$X9 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (df$pA2_first - prev_params[3]))

    } else {

        ## Indication: prevalence is decreasing in the first-step PS.
        df$X7 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (prev_params[1] - df$pA0_first))
        df$X8 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (prev_params[2] - df$pA1_first))
        df$X9 <- as.numeric(runif(n = nrow(df), min = 0, max = 1) <= (prev_params[3] - df$pA2_first))

    }

    ## Return df without intermediate variables to prevent generate_tri_treatment
    ## from failing due to more columns than alphas.
    df %>%
        select(-pA0_first,
               -pA1_first,
               -pA2_first)
}


###  MVN latent variable approach

##' Generate MVN covariates Z_i
##'
##' .. content for details ..
##'
##' @param n Sample size
##' @param mu Mean vector
##' @param Sigma Positive definite variance-covariance matrix
##'
##' @return a data_frame of Z_i MVN covariates
##'
##' @author Kazuki Yoshida
##' @export
generate_mvn_covariates <- function(n, mu, Sigma) {

    assertthat::assert_that(length(n) == 1)
    assertthat::assert_that(is.numeric(n))
    assertthat::assert_that(is.numeric(mu))
    assertthat::assert_that(ncol(Sigma) == length(mu))
    assertthat::assert_that(nrow(Sigma) == length(mu))

    out <- tibble::as_data_frame(
                       MASS::mvrnorm(n = n,
                                     mu = mu,
                                     Sigma = Sigma)
                   )

    names(out) <- gsub("V", "Z", names(out))

    out
}

##' Generate covariates X_i given Z_i and probabilities
##'
##' .. content for details ..
##'
##' @param df data_frame generated by generate_latent_covariates
##' @param prob vector of probabilities of 1 for X_i. If NA is used, X_i := Z_i.
##'
##' @return a data_frame of X_i covariates
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_covariates <- function(df, prob) {

    assertthat::assert_that(ncol(df) == length(prob))

    ## Threshold vector.
    thres <- -qnorm(prob)

    ## Loop over threshold values
    for (i in seq_along(thres)) {
        if (!is.na(thres[i])) {
            ## Only work if threshold is given
            df[,i] <- as.numeric(df[,i] > thres[i])
        }
        ## Nothing happens if thres[i] is NA
    }

    ## rename
    names(df) <- gsub("Z", "X", names(df))

    df
}


###
### Generate treatment
################################################################################

###  Binary
##' Generate a binary treatment
##'
##' .. content for details ..
##'
##' @param df df generated by generate_bin_covariates
##' @param alphas true coefficients for the logistic treatment generating model. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_treatment <- function(df, alphas) {

    assertthat::assert_that(ncol(df) == (length(alphas) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictor
    lpA1 <- as.numeric(Xs %*% alphas)

    ## P[A=1|X] (true PS)
    df$pA1 <- locfit::expit(lpA1)

    ## Bernoulli(pA)
    df$A <- rbinom(n = length(df$pA1),
                   size = 1,
                   prob = df$pA1)

    df
}


###  Three-valued treatment
##' Generate a three-valued treatment
##'
##' .. content for details ..
##'
##' @param df df generated by generate_bin_covariates
##' @param alphas1 true coefficients for the first linear predictor. This vector should contain the intercept.
##' @param alphas2 true coefficients for the second linear predictor. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
##' @export
generate_tri_treatment <- function(df, alphas1, alphas2) {

    assertthat::assert_that(ncol(df) == (length(alphas1) - 1))
    assertthat::assert_that(ncol(df) == (length(alphas2) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictors
    lpA1 <- as.numeric(Xs %*% alphas1)
    lpA2 <- as.numeric(Xs %*% alphas2)

    ## P[A=1|X]/P[A=0|X]
    exp_lpA1 <- exp(lpA1)
    ## P[A=2|X]/P[A=0|X]
    exp_lpA2 <- exp(lpA2)

    ## Common denominator
    denom <- 1 + exp_lpA1 + exp_lpA2

    ## True propensity scores
    df$pA0 <- 1        / denom
    df$pA1 <- exp_lpA1 / denom
    df$pA2 <- exp_lpA2 / denom

    ## n x 3 matrix of true propensity scores
    pA_mat <- cbind(df$pA0, df$pA1, df$pA2)

    ## Generate treatment assignment indicator matrix
    A_mat <- pA_mat_to_A_mat(pA_mat)

    ## Generate three-valued vector
    df$A <- A_indicator_mat_to_multinom_A_vec(A_mat)

    ## Return the augmented data_frame
    df
}

pA_mat_to_A_mat <- function(pA_mat) {

    ## pA_mat is a n x 3 matrix of probability vectors (rows).

    ## transposed 3 x n data_frame
    pA_tr_df <- tibble::as_data_frame(t(pA_mat))

    ## Loop over individuals to obtain n x 3 matrix of treatment indicators.
    A_mat <- lapply(as.list(pA_tr_df),
                    function(pA_vec) {
                        rmultinom(n = 1, size = 1, prob = pA_vec)
                    }) %>%
        do.call(cbind, .) %>%
        t

    A_mat
}

A_indicator_mat_to_multinom_A_vec <- function(A_mat) {

    ## A_mat is a n x 3 matrix of treatment indicators.
    as.numeric(A_mat %*% matrix(c(0,1,2)))
}


###
### Generate outcome
################################################################################

###  Binary outcome given three-valued treatment
##' Generate binary outcome given X_i and three-valued A_i
##'
##' .. content for details ..
##'
##' @param df data_frame containing X_i and A_i
##' @param beta0 Intercept coefficient
##' @param betaA1 Coefficient for I(A_i = 1)
##' @param betaA2 Coefficient for I(A_i = 2)
##' @param betaX Coefficient vector for covariates X_i
##' @param betaXA1 Interaction coefficients for covariates when A_i = 1
##' @param betaXA2 Interaction coefficients for covariates when A_i = 2
##'
##' @return data_frame with binary Y added
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_outcome_log_tri_treatment <- function(df, beta0, betaA1, betaA2, betaX, betaXA1, betaXA2) {

    colnames_starting_with_X <- Filter(f = function(elt) {grepl("^X", elt)}, x = names(df))

    assertthat::assert_that(length(beta0) == 1)
    assertthat::assert_that(length(betaX) == length(colnames_starting_with_X))
    assertthat::assert_that(length(betaA1) == 1)
    assertthat::assert_that(length(betaA2) == 1)
    assertthat::assert_that(length(betaXA1) == length(betaX))
    assertthat::assert_that(length(betaXA2) == length(betaX))

    ## Extract X part as a matrix
    Xs <- as.matrix(df[,colnames_starting_with_X])

    ## Construct treatment indicators from A in {0,1,2}
    A1 <- as.numeric(df$A == 1)
    A2 <- as.numeric(df$A == 2)

    ## Linear predictor matrix (n x 1)
    lpY <- beta0 +
        (betaA1 * A1) +
        (betaA2 * A2) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * A1 +
        Xs %*% matrix(betaXA2) * A2

    assertthat::assert_that(nrow(lpY) == nrow(df))
    assertthat::assert_that(ncol(lpY) == 1)

    ## Counterfactual linear predictors
    lpYA0 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 0
    lpYA1 <- beta0 +
        (betaA1 * 1) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 1 +
        Xs %*% matrix(betaXA2) * 0
    lpYA2 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 1

    ## Probability of binary outcome Y
    ## Truncate at 1 to avoid a probability beyond 1.
    pY   <- pmin(exp(as.numeric(lpY)), 1)
    pYA0 <- pmin(exp(as.numeric(lpYA0)), 1)
    pYA1 <- pmin(exp(as.numeric(lpYA1)), 1)
    pYA2 <- pmin(exp(as.numeric(lpYA2)), 1)

    ## Add to data_frame
    df$pYA0 <- pYA0
    df$pYA1 <- pYA1
    df$pYA2 <- pYA2
    df$pY <- pY

    ## Bernoulli(p_i) draw based on true risk of disease
    df$Y <- rbinom(n = length(pY), size = 1, prob = pY)

    df
}


###  Poisson count outcome given three-valued treatment
##' Generate count outcome given X_i and three-valued A_i
##'
##' .. content for details ..
##'
##' @param df data_frame containing X_i and A_i
##' @param beta0 Intercept coefficient
##' @param betaA1 Coefficient for I(A_i = 1)
##' @param betaA2 Coefficient for I(A_i = 2)
##' @param betaX Coefficient vector for covariates X_i
##' @param betaXA1 Interaction coefficients for covariates when A_i = 1
##' @param betaXA2 Interaction coefficients for covariates when A_i = 2
##'
##' @return data_frame with count Y added
##'
##' @author Kazuki Yoshida
##' @export
generate_count_outcome_log_tri_treatment <- function(df, beta0, betaA1, betaA2, betaX, betaXA1, betaXA2) {

    colnames_starting_with_X <- Filter(f = function(elt) {grepl("^X", elt)}, x = names(df))

    assertthat::assert_that(length(beta0) == 1)
    assertthat::assert_that(length(betaX) == length(colnames_starting_with_X))
    assertthat::assert_that(length(betaA1) == 1)
    assertthat::assert_that(length(betaA2) == 1)
    assertthat::assert_that(length(betaXA1) == length(betaX))
    assertthat::assert_that(length(betaXA2) == length(betaX))

    ## Extract X part as a matrix
    Xs <- as.matrix(df[,colnames_starting_with_X])

    ## Construct treatment indicators from A in {0,1,2}
    A1 <- as.numeric(df$A == 1)
    A2 <- as.numeric(df$A == 2)

    ## Linear predictor matrix (n x 1)
    lpY <- beta0 +
        (betaA1 * A1) +
        (betaA2 * A2) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * A1 +
        Xs %*% matrix(betaXA2) * A2

    assertthat::assert_that(nrow(lpY) == nrow(df))
    assertthat::assert_that(ncol(lpY) == 1)

    ## Counterfactual linear predictors
    lpYA0 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 0
    lpYA1 <- beta0 +
        (betaA1 * 1) +
        (betaA2 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 1 +
        Xs %*% matrix(betaXA2) * 0
    lpYA2 <- beta0 +
        (betaA1 * 0) +
        (betaA2 * 1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0 +
        Xs %*% matrix(betaXA2) * 1

    ## Mean parameter for count outcome Y
    pY   <- exp(as.numeric(lpY))
    pYA0 <- exp(as.numeric(lpYA0))
    pYA1 <- exp(as.numeric(lpYA1))
    pYA2 <- exp(as.numeric(lpYA2))

    ## Add to data_frame
    df$pYA0 <- pYA0
    df$pYA1 <- pYA1
    df$pYA2 <- pYA2
    df$pY   <- pY

    ## Poisson(pY_i) draw based on true risk of disease
    df$Y <- rpois(n = length(pY), lambda = pY)

    df
}


###  Binary outcome given binary treatment
##' Generate binary outcome given X_i and binary A_i
##'
##' .. content for details ..
##'
##' @param df data_frame containing X_i and A_i
##' @param beta0 Intercept coefficient
##' @param betaA1 Coefficient for A_i
##' @param betaX Coefficient vector for covariates X_i
##' @param betaXA1 Interaction coefficients for covariates when A_i = 1
##'
##' @return data_frame with binary Y added
##'
##' @author Kazuki Yoshida
##' @export
generate_bin_outcome_log_bin_treatment <- function(df, beta0, betaX, betaA1, betaXA1) {

    colnames_starting_with_X <- Filter(f = function(elt) {grepl("^X", elt)}, x = names(df))

    assertthat::assert_that(length(beta0) == 1)
    assertthat::assert_that(length(betaX) == length(colnames_starting_with_X))
    assertthat::assert_that(length(betaA1) == 1)
    assertthat::assert_that(length(betaXA1) == length(betaX))

    ## Extract X part as a matrix
    Xs <- as.matrix(df[,colnames_starting_with_X])

    ## Construct treatment indicators from A in {0,1}
    A1 <- df$A

    ## Linear predictor matrix (n x 1)
    lpY <- beta0 +
        (betaA1 * A1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * A1

    assertthat::assert_that(nrow(lpY) == nrow(df))
    assertthat::assert_that(ncol(lpY) == 1)

    ## Counterfactual linear predictors
    lpYA0 <- beta0 +
        (betaA1 * 0) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 0
    lpYA1 <- beta0 +
        (betaA1 * 1) +
        Xs %*% matrix(betaX) +
        Xs %*% matrix(betaXA1) * 1

    ## Tentative probability of binary outcome Y
    pY <- exp(as.numeric(lpY))
    pYA0 <- exp(as.numeric(lpYA0))
    pYA1 <- exp(as.numeric(lpYA1))

    ## Truncate at 1 to avoid a probability beyond 1.
    pY[pY > 1] <- 1
    pYA0[pYA0 > 1] <- 1
    pYA1[pYA1 > 1] <- 1

    ## Add to data_frame
    df$pYA0 <- pYA0
    df$pYA1 <- pYA1
    df$pY <- pY

    ## Bernoulli(p_i)
    df$Y <- rbinom(n = length(pY), size = 1, prob = pY)

    df
}


###
### Generate data one-step
################################################################################

###  Franklin method
##' Generate data by Franklin et al 2014
##'
##' .. content for details ..
##'
##' @param n Sample size
##' @param alphas True coefficients for the first and second treatment linear predictors. This vector should contain the intercept. alphas = c(alpha01, alphaX1, alpha02, alphaX2)
##' @param beta0 Outcome model intercept coefficient
##' @param betaA Outcome model coefficient for I(A_i = 1) and I(A_i = 2)
##' @param betaX Outcome model coefficient vector for covariates X_i
##' @param betaXA1 Outcome model interaction coefficients for covariates. betaXA = c(betaXA1, betaXA2)
##'
##' @return a complete simulated data_frame
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_franklin_data <- function(n,
                                   alphas,
                                   beta0,
                                   betaA,
                                   betaX,
                                   betaXA) {

    n_covariates <- length(betaX)
    assertthat::assert_that(n_covariates == 10)
    ## alphas = c(alphas1, alphas2) and includes two intercepts.
    assertthat::assert_that(length(alphas) == 2 * (n_covariates + 1))
    assertthat::assert_that(length(beta0) == 1)
    ## betaA = c(betaA1, betaA2)
    assertthat::assert_that(length(betaA) == 2)
    ## betaXA = c(betaXA1, betaXA2)
    assertthat::assert_that(length(betaXA) == 2 * n_covariates)

    ## Destructure parameters
    alphas1 <- alphas[seq_len(n_covariates + 1)]
    alphas2 <- alphas[(n_covariates + 1) + seq_len(n_covariates + 1)]
    betaA1 <- betaA[1]
    betaA2 <- betaA[2]
    betaXA1 <- betaXA[seq_len(n_covariates)]
    betaXA2 <- betaXA[n_covariates + seq_len(n_covariates)]

    n %>%
        generate_franklin_covariates(.) %>%
        generate_tri_treatment(., alphas1, alphas2) %>%
        generate_bin_outcome_log_tri_treatment(., beta0, betaA1, betaA2, betaX, betaXA1, betaXA2)

}


###  Sturmer method
##' Generate data by the extended version of Sturmer et al 2010
##'
##' .. content for details ..
##'
##' @param n Sample size
##' @param alphas True coefficients for the first and second treatment linear predictors. This vector should contain the intercept. alphas = c(alpha01, alphaX1, alpha02, alphaX2)
##' @param prev_params Prevalence parameters. A vector of length 3.
##' @param contraindication Logical to determine whether to parametrize based on contraindication. If \code{TRUE}, the unmeasured binary variables are more common in the high PS regions (corners in the PS ternary plot). If \code{FALSE}, the unmeasured binary variables are more common in the low PS regions (edges in the PS ternary plot).
##' @param beta0 Outcome model intercept coefficient
##' @param betaA Outcome model coefficient for I(A_i = 1) and I(A_i = 2)
##' @param betaX Outcome model coefficient vector for covariates X_i
##' @param betaXA1 Outcome model interaction coefficients for covariates. betaXA = c(betaXA1, betaXA2)
##' @param outcome_fun Outcome generating function. Either one of \code{\link{generate_bin_outcome_log_tri_treatment}} or \code{\link{generate_count_outcome_log_tri_treatment}}
##'
##' @return a complete simulated data_frame
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_sturmer_data <- function(n,
                                  ## Treatment assignment
                                  alphas,
                                  prev_params,
                                  contraindication,
                                  ## Outcome assignment
                                  beta0,
                                  betaA,
                                  betaX,
                                  betaXA,
                                  outcome_fun) {

    n_covariates <- length(betaX)
    assertthat::assert_that(n_covariates == 9)
    ## alphas = c(alphas1, alphas2) and includes two intercepts.
    assertthat::assert_that(length(alphas) == 2 * (n_covariates + 1))
    assertthat::assert_that(length(beta0) == 1)
    ## Prevalence parameters for X7-X9
    assertthat::assert_that(length(prev_params) == 3)
    ## Contraindication or indication parametrization.
    assertthat::assert_that(length(contraindication) == 1)
    assertthat::assert_that(is.logical(contraindication))
    ## betaA = c(betaA1, betaA2)
    assertthat::assert_that(length(betaA) == 2)
    ## betaXA = c(betaXA1, betaXA2)
    assertthat::assert_that(length(betaXA) == 2 * n_covariates)

    ## Destructure parameters
    alphas1 <- alphas[seq_len(n_covariates + 1)]
    alphas2 <- alphas[(n_covariates + 1) + seq_len(n_covariates + 1)]
    betaA1 <- betaA[1]
    betaA2 <- betaA[2]
    betaXA1 <- betaXA[seq_len(n_covariates)]
    betaXA2 <- betaXA[n_covariates + seq_len(n_covariates)]

    n %>%
        generate_sturmer_base_covariates(.) %>%
        ## Only use first 7 alpha parameters.
        generate_sturmer_unmeasured_covariates(., alphas1[1:7], alphas2[1:7], prev_params, contraindication) %>%
        ## Treatment and outcome assignment is the same.
        generate_tri_treatment(., alphas1, alphas2) %>%
        outcome_fun(., beta0, betaA1, betaA2, betaX, betaXA1, betaXA2)

}

###   Define specialized versions
##' Generate data by the extended version of Sturmer et al 2010 (binary outcome)
##'
##' .. content for details ..
##'
##' @param n Sample size
##' @param alphas True coefficients for the first and second treatment linear predictors. This vector should contain the intercept. alphas = c(alpha01, alphaX1, alpha02, alphaX2)
##' @param prev_params Prevalence parameters. A vector of length 3.
##' @param contraindication Logical to determine whether to parametrize based on contraindication. If \code{TRUE}, the unmeasured binary variables are more common in the high PS regions (corners in the PS ternary plot). If \code{FALSE}, the unmeasured binary variables are more common in the low PS regions (edges in the PS ternary plot).
##' @param beta0 Outcome model intercept coefficient
##' @param betaA Outcome model coefficient for I(A_i = 1) and I(A_i = 2)
##' @param betaX Outcome model coefficient vector for covariates X_i
##' @param betaXA1 Outcome model interaction coefficients for covariates. betaXA = c(betaXA1, betaXA2)
##'
##' @return a complete simulated data_frame
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_sturmer_data_bin <- function(n,
                                      ## Treatment assignment
                                      alphas,
                                      prev_params,
                                      contraindication,
                                      ## Outcome assignment
                                      beta0,
                                      betaA,
                                      betaX,
                                      betaXA) {
    generate_sturmer_data(n,
                          ## Treatment assignment
                          alphas,
                          prev_params,
                          contraindication,
                          ## Outcome assignment
                          beta0,
                          betaA,
                          betaX,
                          betaXA,
                          outcome_fun = generate_bin_outcome_log_tri_treatment)
}

##' Generate data by the extended version of Sturmer et al 2010 (count outcome)
##'
##' .. content for details ..
##'
##' @param n Sample size
##' @param alphas True coefficients for the first and second treatment linear predictors. This vector should contain the intercept. alphas = c(alpha01, alphaX1, alpha02, alphaX2)
##' @param prev_params Prevalence parameters. A vector of length 3.
##' @param contraindication Logical to determine whether to parametrize based on contraindication. If \code{TRUE}, the unmeasured binary variables are more common in the high PS regions (corners in the PS ternary plot). If \code{FALSE}, the unmeasured binary variables are more common in the low PS regions (edges in the PS ternary plot).
##' @param beta0 Outcome model intercept coefficient
##' @param betaA Outcome model coefficient for I(A_i = 1) and I(A_i = 2)
##' @param betaX Outcome model coefficient vector for covariates X_i
##' @param betaXA1 Outcome model interaction coefficients for covariates. betaXA = c(betaXA1, betaXA2)
##'
##' @return a complete simulated data_frame
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_sturmer_data_count <- function(n,
                                        ## Treatment assignment
                                        alphas,
                                        prev_params,
                                        contraindication,
                                        ## Outcome assignment
                                        beta0,
                                        betaA,
                                        betaX,
                                        betaXA) {
    generate_sturmer_data(n,
                          ## Treatment assignment
                          alphas,
                          prev_params,
                          contraindication,
                          ## Outcome assignment
                          beta0,
                          betaA,
                          betaX,
                          betaXA,
                          outcome_fun = generate_count_outcome_log_tri_treatment)
}


###  Generic method that takes function as an argument
##' Generate data based on a given specific function
##'
##' .. content for details ..
##'
##' @param fun Data generation function such as \code{\link{generate_franklin_data}}.
##' @param lst_params one list of arguments that \code{fun} can take.
##'
##' @return a complete simulated data_frame
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_data <- function(fun, lst_params) {

    if ("data.frame" %in% class(lst_params)) {
        ## If it is a data frame, it must be only one row
        assertthat::assert_that(nrow(lst_params) == 1)
    }

    ## Number of arguments fun takes
    n_fun_args <- length(formals(fun))
    ## Number of elements
    n_params <- length(lst_params)
    ## Must match
    assertthat::assert_that(n_fun_args == n_params)

    ## Their names must match up.
    names_fun_args <- names(formals(fun))
    names_params <- names(lst_params)
    assertthat::assert_that(all(names_fun_args == names_params))

    ## With above confirmed, can just call
    ## tidyverse depends on magrittr.
    df <- lst_params %>%
        ## Peel each list column cell to a vector.
        lapply(., magrittr::extract2, 1) %>%
        ## Use the list of vectors as arguments.
        do.call(fun, .)

    ## Add class datagen3
    class(df) <- c("datagen3", class(df))

    df
}


###  print method for datagen3 object
##' Print method for simulated data
##'
##' .. content for details ..
##'
##' @param x data_frame with an additional class \code{datagen3}
##' @param ...
##'
##' @return invisibly return a matrix object
##'
##' @author Kazuki Yoshida
##' @export
print.datagen3 <- function(x, ...) {

    ## Construct
    tab_overall <- print(tableone::CreateTableOne(data = x),
                         printToggle = FALSE)
    tab_strata  <- print(tableone::CreateTableOne(data = x, strata = "A", test = FALSE, smd = TRUE),
                         smd = TRUE, printToggle = FALSE)
    tab_combo <- cbind(tab_overall, tab_strata)

    print(tab_combo, quote = FALSE)

    invisible(tab_combo)
}


###
### Generate scenario set
################################################################################

##' Create a data_frame of list columns representing scenarios
##'
##' A row in the output data_frame represents a distinct scenario whereas each column represents a distinct argument to be given to the data generation function.
##'
##' @param lst_lst_possible_values named list of named lists of possible values.
##'
##' @return data_frame with a \code{scenarios} class attribute holding one scenario in each row.
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_scenario_data_frame <- function(lst_lst_possible_values) {

    ## All list elements must be named.
    assertthat::assert_that(all(!is.null(names(lst_lst_possible_values))))
    ## All list elements must be lists.
    assertthat::assert_that(all(unlist(lapply(lst_lst_possible_values, class)) == "list"))

    ## Expand scenarios to create all possible values.
    df <- do.call(expand.grid, lst_lst_possible_values) %>%
        as_data_frame

    ## Add scenario description generated from list element names in lst_lst_possible_values.
    scenario_description <- lapply(df, names) %>%
        Filter(f = function(elt) {!is.null(elt)}, x = .) %>%
        do.call(function(...) {paste(..., sep = ";")}, .)

    if (length(scenario_description) == nrow(df)) {
        ## Use if we have valid number of descriptions.
        df$description <- scenario_description
    } else {
        ## Otherwise just empty strings
        df$description <- rep("", nrow(df))
    }

    ## Add scenarios attribute.
    class(df) <- c("scenarios", class(df))

    df
}


###
### Generate data and save
################################################################################

##' Generate R iterations for a single scenario
##'
##' Given a parameter set for a single scenario, generate R iterations of distributed research network.
##'
##' @param fun specific data generator function
##' @param scenario A row of scenarios data_frame.
##' @param R Scalar value. Data are generated R times.
##' @param scenario_count Scalar value. Indicate the scenario count. Used for data file name.
##' @param part_count Scalar value. Indicates which subpart of the scenario this part is.
##' @param scenario_description A character value describing the current scenario.
##'
##' @return Use for its side effect. No return value. Save a data file in the working directory.
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_r_times_and_save <- function(fun, scenario, R, scenario_count, part_count, scenario_description) {
    ## Sanity check
    assertthat::assert_that(is.numeric(R))
    assertthat::assert_that(length(R) == 1)
    assertthat::assert_that(is.numeric(scenario_count))
    assertthat::assert_that(length(scenario_count) == 1)
    assertthat::assert_that(is.numeric(part_count))
    assertthat::assert_that(length(part_count) == 1)
    assertthat::assert_that(is.character(scenario_description))
    assertthat::assert_that(length(scenario_description) == 1)

    ## Generate R iterations for a single scenario
    ## This is not parallelized. Parallelize the outer loop over scenarios.
    ## List of R iterations. Each iteration is a list of K centers.
    lst_iter <- lapply(seq_len(R), function(i) {

        generate_data(fun,
                      scenario)

    })

    ## Generate file name
    filename <- sprintf("scenario_raw%03d_part%03d_r%d.RData",
                        scenario_count,
                        part_count,
                        R)

    ## Save
    save(scenario, R, scenario_count, part_count, scenario_description,
         lst_iter,
         file = filename)

    ## No return value
    NULL
}


##' Generate R iterations for each scenario
##'
##' Given an iteration count and a list of scenario parameters for multiple scenarios (\code{Scenarios} object), generate R datasets for each scenario. If a scenario within a \code{Scenarios} object is corrupt (not correctly a \code{ScenarioDistResNet} object), it is skipped by \code{try}.
##'
##' @param fun specific data generator function
##' @param scenarios a scenarios object. Each list row is a specification for a given scenario. A character column named description is expected.
##' @param parts how many subfiles to create for each scenario. Use this to ease parallelization across cluster nodes.
##' @param R iteration count for each subfile. The total iteration count for a given scenario is \code{parts * R}.
##' @param skip row numbers of the scenario object to skip data generation.
##'
##' @return Use for its side effect. There is no return value. Data files are created in the same folder.
##'
##' @author Kazuki Yoshida
##'
##' @export
generate_data_for_all_scenarios <- function(fun, scenarios, n_parts, R, skip) {
    ## Sanity check
    assertthat::assert_that("scenarios" %in% class(scenarios))
    assertthat::assert_that(is.numeric(n_parts))
    assertthat::assert_that(length(n_parts) == 1)
    assertthat::assert_that(is.numeric(R))
    assertthat::assert_that(length(R) == 1)
    assertthat::assert_that(is.numeric(skip))

    ## Message for information
    cat("### Generating data files.\n")
    cat("### Generating data files for", nrow(scenarios), "scenarios.\n")
    cat("###", n_parts,
        "subfiles with", R,
        "iterations each for each scenario.\n")
    cat("### Total iteration count:", n_parts*R, "for each scenario.\n")

    ## Generate all possible (scenario_count, part_count) tuples
    ## and put in a list
    tuples_senario_count_part <-
        crossing(scenario_count = seq_len(nrow(scenarios)),
                 part_count     = seq_len(n_parts)) %>%
        t %>%
        as.data.frame %>%
        as.list

    ## Reproducible parallel execution
    ## Parallelization is at the file level, i.e., (scenario, part) tuple level
    foreach::foreach(senario_count_part = tuples_senario_count_part) %dorng% {

        ## Assign values for readability
        scenario_count <- senario_count_part[1]
        part_count     <- senario_count_part[2]


        if (scenario_count %in% skip) {
            cat("### Skipping Scenario", scenario_count,
                "Part", part_count, "\n")

        } else {
            cat("### Generating Scenario", scenario_count,
                "Part", part_count, "\n")

            ## Generate the part_count-th subfile for the scenario_count-th scenario.
            try(generate_r_times_and_save(fun = fun,
                                          scenario = scenarios[scenario_count,] %>% select(-description),
                                          R = R,
                                          scenario_count = scenario_count,
                                          part_count = part_count,
                                          scenario_description = as.character(scenarios[scenario_count,"description"])))
        }

        ## No return value
        NULL
    }

    ## This is a void function that returns NULL.
    NULL
}
