###
### Data Generator for 3-Group CER Simulation
################################################################################


##' Generate MVN covariates Z_i
##'
##' .. content for \details{} ..
##'
##' @param n Sample size
##' @param mu Mean vector
##' @param Sigma Positive definite variance-covariance matrix
##'
##' @return a data_frame of Z_i MVN covariates
##'
##' @author Kazuki Yoshida
generate_mvn_covariates <- function(n, mu, Sigma) {

    assertthat::assert_that(length(n) == 1)
    assertthat::assert_that(is.numeric(n))
    assertthat::assert_that(is.numeric(mu))
    assertthat::assert_that(ncol(mu) == length(mu))
    assertthat::assert_that(nrow(mu) == length(mu))

    out <- tibble::as_data_frame(
                       MASS::mvrnorm(n = n,
                                     mu = mu,
                                     Sigma = Sigma)
                   )

    names(out) <- gsub("V", "Z", names(out))

    out
}


##' Generate covariates X_i given Z_i and probabilities
##'
##' .. content for \details{} ..
##'
##' @param df data_frame generated by generate_latent_covariates
##' @param prob vector of probabilities of 1 for X_i
##'
##' @return a data_frame of X_i covariates
##'
##' @author Kazuki Yoshida
generate_covariates <- function(df, prob) {

    assertthat::assert_that(ncol(df) == length(prob))

    ## Threshold vector.
    thres <- -qnorm(prob)

    sweep(df, MARGIN = 2, STATS = thres, FUN = `>`) %>%
        as_data_frame %>%
        mutate_all(as.numeric) %>%
        rename_all(function(x) {gsub("Z","X",x)})
}


##' Generate a binary treatment
##'
##' .. content for \details{} ..
##'
##' @param df df generated by generate_covariates
##' @param alphas true coefficients for the logistic treatment generating model. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
generate_bin_treatment <- function(df, alphas) {

    assertthat::assert_that(ncol == (length(alphas) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictor
    lp <- as.numeric(Xs %*% alphas)

    ## P[A=1|X] (true PS)
    pA <- locfit::expit(lp)

    ## Bernoulli(pA)
    df$A <- rbinom(n = length(pA),
                   size = 1,
                   prob = pA)

    df
}


##' Generate a three-valued treatment
##'
##' .. content for \details{} ..
##'
##' @param df df generated by generate_covariates
##' @param alphas1 true coefficients for the first logistic treatment generating model. This vector should contain the intercept.
##' @param alphas2 true coefficients for the second logistic treatment generating model. This vector should contain the intercept.
##'
##' @return df with treatment (A) added.
##'
##' @author Kazuki Yoshida
generate_tri_treatment <- function(df, alphas1, alphas2) {

    assertthat::assert_that(ncol == (length(alphas1) - 1))
    assertthat::assert_that(ncol == (length(alphas2) - 1))

    ## X matrix
    Xs <- as.matrix(df)

    ## Add constant term
    Xs <- cbind(rep(1, nrow(Xs)), Xs)

    ## Linear predictors
    lp1 <- as.numeric(Xs %*% alphas1)
    lp2 <- as.numeric(Xs %*% alphas2)

    ## P[A=1|X]/P[A=0|X]
    exp_lp1 <- exp(lp1)
    ## P[A=2|X]/P[A=0|X]
    exp_lp2 <- exp(lp2)

    ## Common denominator
    denom <- 1 + exp_lp1 + exp_lp2

    ## True propensity scores
    pA0 <- 1       / denom
    pA1 <- exp_lp1 / denom
    pA2 <- exp_lp2 / denom

    ## n x 3 matrix of true propensity scores
    pA_mat <- cbind(pA0, pA1, pA2)

    ## Generate treatment assignment indicator matrix
    A_mat <- pA_mat_to_A_mat(pA_mat)

    ## Generate three-valued vector
    df$A <- A_indicator_to_multinom_A(A_mat)

    ## Return the augmented data_frame
    df
}

pA_mat_to_A_mat <- function(pA_mat) {

    ## pA_mat is a n x 3 matrix of probability vectors (rows).
    
    ## transposed 3 x n data_frame
    pA_tr_df <- tibble::as_data_frame(t(pA_mat))

    ## Loop over individuals to obtain n x 3 matrix of treatment indicators.
    A_mat <- lapply(as.list(pA_tr_df),
                    function(pA_vec) {
                        rmultinom(n = 1, size = 1, prob = pA_vec)
                    }) %>%
        do.call(rbind, .)

    A_mat
}

